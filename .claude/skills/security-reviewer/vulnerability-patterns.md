# Language-Specific Vulnerability Patterns

## Go-Specific Vulnerabilities

### Command Injection
```go
// VULNERABLE — user input in shell command
cmd := exec.Command("sh", "-c", "echo " + userInput)

// SAFE — arguments passed as separate args
cmd := exec.Command("echo", userInput)
```

### Path Traversal
```go
// VULNERABLE — user controls file path
filePath := filepath.Join(baseDir, userInput)
data, _ := os.ReadFile(filePath) // userInput = "../../etc/passwd"

// SAFE — clean and verify path stays within base
filePath := filepath.Join(baseDir, filepath.Clean(userInput))
if !strings.HasPrefix(filePath, baseDir) {
    return errors.New("path traversal attempt")
}
```

### SQL Injection
```go
// VULNERABLE — string concatenation
query := "SELECT * FROM users WHERE id = " + userID
db.Query(query)

// SAFE — parameterized query
db.Query("SELECT * FROM users WHERE id = ?", userID)
```

### Insecure Randomness
```go
// VULNERABLE — predictable for security tokens
import "math/rand"
token := rand.Int63()

// SAFE — cryptographically secure
import "crypto/rand"
b := make([]byte, 32)
crypto_rand.Read(b)
token := hex.EncodeToString(b)
```

### Race Conditions
```go
// VULNERABLE — TOCTOU on file check
if _, err := os.Stat(path); err == nil {
    // file exists, read it
    data, _ := os.ReadFile(path) // file could be swapped between check and read
}

// VULNERABLE — shared state without sync
var isAdmin bool // set in one goroutine, read in another

// SAFE — use mutex or atomic
var mu sync.Mutex
mu.Lock()
isAdmin = checkAdmin(user)
mu.Unlock()
```

### Goroutine Leak / Resource Exhaustion
```go
// VULNERABLE — unbounded goroutine creation from user input
for _, item := range userItems { // userItems could be enormous
    go process(item)
}

// SAFE — bounded worker pool
sem := make(chan struct{}, maxWorkers)
for _, item := range userItems {
    sem <- struct{}{}
    go func(i Item) {
        defer func() { <-sem }()
        process(i)
    }(item)
}
```

### Unsafe HTTP Defaults
```go
// VULNERABLE — no timeouts, no size limits
http.ListenAndServe(":8080", handler)

// SAFE — configured server
srv := &http.Server{
    Addr:         ":8080",
    ReadTimeout:  10 * time.Second,
    WriteTimeout: 10 * time.Second,
    IdleTimeout:  120 * time.Second,
    MaxHeaderBytes: 1 << 20,
    Handler:      handler,
}
```

### Unvalidated Redirects
```go
// VULNERABLE — open redirect
redirectURL := r.URL.Query().Get("redirect")
http.Redirect(w, r, redirectURL, http.StatusFound)

// SAFE — validate against allowlist
if !isAllowedRedirect(redirectURL) {
    http.Redirect(w, r, "/", http.StatusFound)
    return
}
```

## TypeScript/JavaScript-Specific Vulnerabilities

### XSS (Cross-Site Scripting)
```tsx
// VULNERABLE — dangerouslySetInnerHTML with user input
<div dangerouslySetInnerHTML={{ __html: userInput }} />

// VULNERABLE — href with user-controlled protocol
<a href={userInput}>Click</a> // userInput = "javascript:alert(1)"

// SAFE — React auto-escapes in JSX
<div>{userInput}</div>

// SAFE — validate URL protocol
const url = new URL(userInput);
if (!['http:', 'https:'].includes(url.protocol)) throw new Error('Invalid URL');
```

### Prototype Pollution
```js
// VULNERABLE — merging user-controlled objects
Object.assign(target, userInput) // userInput = {"__proto__": {"isAdmin": true}}

// SAFE — validate keys
const safeKeys = ['name', 'email'];
const filtered = Object.fromEntries(
    Object.entries(userInput).filter(([k]) => safeKeys.includes(k))
);
```

### Insecure Dependencies
```json
// VULNERABLE — unpinned versions
"dependencies": {
    "lodash": "^4.0.0"  // could resolve to compromised version
}

// SAFER — pinned with lockfile
"dependencies": {
    "lodash": "4.17.21"
}
```

### eval / Function Constructor
```js
// VULNERABLE — executing user input
eval(userInput)
new Function(userInput)()
setTimeout(userInput, 0) // string form

// SAFE — never execute user-controlled strings
```

### SSRF via fetch
```js
// VULNERABLE — fetching user-supplied URL server-side
const response = await fetch(userInput);

// SAFE — validate against allowlist
const url = new URL(userInput);
if (!ALLOWED_HOSTS.includes(url.hostname)) throw new Error('Blocked');
```

## Common Patterns Across Languages

### Timing Attacks
```go
// VULNERABLE — early return reveals information
if token[0] != expected[0] { return false }
if token[1] != expected[1] { return false }

// SAFE — constant-time comparison
import "crypto/subtle"
subtle.ConstantTimeCompare([]byte(token), []byte(expected))
```

### Mass Assignment
```go
// VULNERABLE — binding all fields from request
json.NewDecoder(r.Body).Decode(&user) // could set user.IsAdmin = true

// SAFE — bind to specific DTO, then map allowed fields
var req CreateUserRequest
json.NewDecoder(r.Body).Decode(&req)
user.Name = req.Name
user.Email = req.Email
```

### Error Information Leakage
```go
// VULNERABLE — exposing internal errors
http.Error(w, err.Error(), 500) // could reveal DB schema, file paths

// SAFE — generic message, log details internally
log.Error("query failed", "error", err)
http.Error(w, "internal server error", 500)
```
